{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido","text":""},{"location":"#modelo-de-ising-cuantico-unidimensional-en-una-grilla-de-n-espines","title":"Modelo de Ising cu\u00e1ntico unidimensional en una grilla de \\( N \\) espines","text":"<p>El modelo de Ising cu\u00e1ntico es una extensi\u00f3n natural del modelo de Ising cl\u00e1sico, uno de los m\u00e1s simples y famosos para describir materiales magn\u00e9ticos, propuesto por Ernst Ising en 1925.</p> <p>Para el modelo cl\u00e1sico, se tiene una red donde cada punto contiene un esp\u00edn que puede tomar solo dos valores \\( s_i = \\pm1 \\). El sistema busca minimizar su energ\u00eda total dependiendo de c\u00f3mo interact\u00faan los espines. Para medir la energ\u00eda total de una configuraci\u00f3n se usa el siguiente Hamiltoniano cl\u00e1sico:</p> \\[ H = -J \\sum_{\\langle i, j\\rangle} s_i s_j - h \\sum_{i} s_i \\] <p>Donde:</p> <ul> <li>\\( s_i = \\pm 1 \\) es el esp\u00edn cl\u00e1sico en el sitio \\( i \\),</li> <li>\\( J \\) es la constante de acoplamiento:</li> <li>\\( J &gt; 0 \\): favorece que los espines se alineen (ferromagnetismo),</li> <li>\\( J &lt; 0 \\): favorece que se desalineen (antiferromagnetismo),</li> <li>\\( h \\) es el campo magn\u00e9tico externo cl\u00e1sico.</li> </ul>"},{"location":"#hamiltoniano-del-modelo-cuantico","title":"Hamiltoniano del modelo cu\u00e1ntico","text":"<p>El modelo de Ising cu\u00e1ntico permite estudiar el comportamiento colectivo de muchos espines cu\u00e1nticos en una red, donde los espines pueden interactuar entre s\u00ed \\( \\text{(alinearse o desalinearse)} \\). El Hamiltoniano del modelo cu\u00e1ntico 1D con campo transversal (perpendicular al eje de los espines) es:</p> \\[ \\hat{H} = -J\\sum_{i=1}^{N-1} \\hat{\\sigma}_{i}^{z} \\hat{\\sigma}_{i + 1}^z - g \\sum_{i = 1}^N \\hat{\\sigma}_{i}^x \\] <p>Donde:</p> <ul> <li>\\( J \\): escala energ\u00e9tica de la interacci\u00f3n ferromagn\u00e9tica,</li> <li>\\( g \\): intensidad del campo transversal cu\u00e1ntico,</li> <li>\\( \\hat{\\sigma}_{i}^{z} \\): matriz de Pauli-Z que mide si un esp\u00edn est\u00e1 en \\( \\uparrow \\) o \\( \\downarrow \\),</li> <li>\\( \\hat{\\sigma}_{i}^{x} \\): matriz de Pauli-X que representa la posibilidad de cambio de estado \\( \\left(\\uparrow \\leftrightarrow \\downarrow \\right) \\).</li> </ul>"},{"location":"#matrices-de-pauli","title":"Matrices de Pauli","text":"\\[ \\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix}, \\quad I = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"#interpretacion-fisica-del-hamiltoniano","title":"Interpretaci\u00f3n f\u00edsica del Hamiltoniano","text":"<p>Primer t\u00e9rmino \\( \\hat{\\sigma}_{i}^{z} \\hat{\\sigma}_{i+1}^{z} \\): - Representa la interacci\u00f3n entre espines vecinos. - Si est\u00e1n alineados \\( (\\uparrow\\uparrow \\text{ o } \\downarrow\\downarrow) \\), da baja energ\u00eda. - Si est\u00e1n opuestos \\( (\\uparrow\\downarrow \\text{ o } \\downarrow\\uparrow) \\), da mayor energ\u00eda.</p> <p>Segundo t\u00e9rmino \\( \\hat{\\sigma}_{i}^x \\): - Representa la acci\u00f3n de un campo en la direcci\u00f3n \\( x \\), - Introduce fluctuaciones cu\u00e1nticas que permiten que los espines cambien de estado.</p>"},{"location":"#competencia-entre-orden-y-fluctuacion","title":"Competencia entre orden y fluctuaci\u00f3n","text":"<ul> <li>Cuando \\( h = 0 \\): s\u00f3lo hay interacci\u00f3n entre espines \u2192 tienden a estar alineados \u2192 estado ferromagn\u00e9tico.</li> <li>Cuando \\( J = 0 \\): los espines siguen solo el campo externo \u2192 act\u00faan independientemente \u2192 estado paramagn\u00e9tico.</li> <li>Cuando \\( h \\sim J \\): hay un equilibrio \u2192 aparece una transici\u00f3n cu\u00e1ntica de fase.</li> </ul>"},{"location":"#representacion-en-mecanica-cuantica","title":"Representaci\u00f3n en mec\u00e1nica cu\u00e1ntica","text":"<p>Cada esp\u00edn vive en un espacio de dimensi\u00f3n 2 ( \\( \\uparrow \\) o \\( \\downarrow \\) ). Una cadena de \\( N \\) espines tiene un espacio de estados de dimensi\u00f3n \\( 2^N \\). Por ejemplo:</p> <ul> <li>\\( N = 1 \\): estados = \\( \\{ \\uparrow, \\downarrow \\} \\)</li> <li>\\( N = 2 \\): estados = \\( \\{ \\uparrow\\uparrow, \\uparrow\\downarrow, \\downarrow\\uparrow, \\downarrow\\downarrow \\} \\)</li> <li>\\( N = 3 \\): estados = \\( \\{ \\uparrow\\uparrow\\uparrow, \\uparrow\\uparrow\\downarrow, \\ldots, \\downarrow\\downarrow\\downarrow \\} \\Rightarrow 8 \\) posibles</li> </ul> <p>El Hamiltoniano es entonces una matriz de dimensi\u00f3n \\( 2^N \\times 2^N \\) que describe todas las interacciones posibles del sistema.</p>"},{"location":"#dinamica-cuantica","title":"Din\u00e1mica cu\u00e1ntica","text":"<p>A diferencia del modelo cl\u00e1sico, en el modelo cu\u00e1ntico el Hamiltoniano tambi\u00e9n describe la evoluci\u00f3n temporal del estado del sistema:</p> \\[ \\frac{\\partial |\\psi(t)\\rangle}{\\partial t} = -i\\hat{H} |\\psi(t)\\rangle \\] <p>La soluci\u00f3n de esta ecuaci\u00f3n es:</p> \\[ |\\psi(t)\\rangle = e^{-i \\hat{H}(t - t_0)} |\\psi(t = t_0)\\rangle \\] <p>Este formalismo permite estudiar:</p> <ul> <li>Din\u00e1mica de espines y correlaciones en el tiempo,</li> <li>Entrelazamiento cu\u00e1ntico,</li> <li>Simulaci\u00f3n cu\u00e1ntica de materiales y algoritmos cu\u00e1nticos.</li> </ul>"},{"location":"#implementacion-numerica","title":"Implementaci\u00f3n num\u00e9rica","text":"<p>Para implementar este modelo en c\u00f3digo (por ejemplo, en C++), es necesario:</p> <ul> <li>Representar las matrices de Pauli y la Identidad como matrices <code>2x2</code>.</li> <li>Usar el producto tensorial para construir las matrices que act\u00faan sobre el espacio completo de dimensi\u00f3n \\( 2^N \\).</li> <li>Construir el Hamiltoniano sumando los t\u00e9rminos de interacci\u00f3n y campo.</li> <li>Diagonalizar el Hamiltoniano para obtener autovalores y autovectores.</li> <li>Evolucionar el estado en el tiempo con \\( e^{-iHt} \\mid \\psi(0) \\rangle \\).</li> </ul> <p>Este procedimiento es computacionalmente costoso para \\( N &gt; 10 \\), por lo que se aplica principalmente a sistemas peque\u00f1os.</p>"},{"location":"codigo/","title":"C\u00f3digo del modelo de Ising cu\u00e1ntico en Python","text":"<p>Este apartado presenta la implementaci\u00f3n completa del modelo de Ising cu\u00e1ntico unidimensional con campo transversal, un sistema fundamental en la f\u00edsica de muchos cuerpos. A continuaci\u00f3n, se explica cada parte del c\u00f3digo que simula su din\u00e1mica cu\u00e1ntica.</p>"},{"location":"codigo/#hamiltoniano-del-modelo","title":"Hamiltoniano del modelo","text":"<p>El Hamiltoniano est\u00e1 dado por:</p> \\[ H = -J \\sum_{i=1}^{N-1} \\sigma^z_i \\sigma^z_{i+1} - g \\sum_{i=1}^N \\sigma^x_i \\] <p>donde: - \\( \\sigma^x \\) y \\( \\sigma^z \\) son matrices de Pauli, - \\( J \\) es la constante de acoplamiento entre espines vecinos, - \\( g \\) es la intensidad del campo transversal, - \\( N \\) es el n\u00famero total de espines en la cadena.</p>"},{"location":"codigo/#implementacion-del-modelo-en-python","title":"Implementaci\u00f3n del modelo en Python","text":"<pre><code>import numpy as np\nfrom functools import reduce\nfrom scipy.linalg import expm\n</code></pre>"},{"location":"codigo/#matrices-de-pauli-y-matriz-identidad","title":"Matrices de Pauli y matriz identidad","text":"<pre><code>I = np.eye(2)\nsx = np.array([[0, 1], [1, 0]])   # \u03c3_x\nsz = np.array([[1, 0], [0, -1]])  # \u03c3_z\n</code></pre>"},{"location":"codigo/#producto-tensorial","title":"Producto tensorial","text":"<pre><code>def producto_tensorial(matrices):\n    return reduce(np.kron, matrices)\n</code></pre>"},{"location":"codigo/#construccion-del-hamiltoniano","title":"Construcci\u00f3n del Hamiltoniano","text":"<pre><code>def hamiltoniano(N, J, g):\n    H = np.zeros((2**N, 2**N))\n\n    # T\u00e9rmino de interacci\u00f3n \u03c3^z_i \u03c3^z_{i+1}\n    for i in range(N - 1):\n        op_z = [I] * N\n        op_z[i] = sz\n        op_z[i + 1] = sz\n        H -= J * producto_tensorial(op_z)\n\n    # T\u00e9rmino de campo transversal \u03c3^x_i\n    for i in range(N):\n        op_x = [I] * N\n        op_x[i] = sx\n        H -= g * producto_tensorial(op_x)\n\n    return H\n</code></pre>"},{"location":"codigo/#estado-inicial-todos-los-espines-arriba","title":"Estado inicial: todos los espines arriba","text":"<pre><code>def estado_inicial(N):\n    arriba = np.array([[1], [0]])  # Estado |0\u27e9\n    return producto_tensorial([arriba] * N)\n</code></pre>"},{"location":"codigo/#evolucion-temporal-del-sistema","title":"Evoluci\u00f3n temporal del sistema","text":"<pre><code>def evolucion(psi0, H, tiempos):\n    estados = []\n    for t in tiempos:\n        U = expm(-1j * H * t)\n        psi_t = U @ psi0\n        estados.append(psi_t)\n    return estados\n</code></pre>"},{"location":"codigo/#operador-z-en-el-sitio-i","title":"Operador \u03c3^z en el sitio i","text":"<pre><code>def sigma_z_en_i(N, i):\n    ops = [I] * N\n    ops[i] = sz\n    return producto_tensorial(ops)\n</code></pre>"},{"location":"codigo/#magnetizacion-langle-sigmaz_i-rangle-t","title":"Magnetizaci\u00f3n \\( \\langle \\sigma^z_i \\rangle (t) \\)","text":"<pre><code>def magnetizacion_z(estados, N):\n    magnetizaciones = np.zeros((len(estados), N))\n    for t_idx, psi in enumerate(estados):\n        for i in range(N):\n            Sz_i = sigma_z_en_i(N, i)\n            magnetizaciones[t_idx, i] = np.real((psi.conj().T @ Sz_i @ psi).item())\n    return magnetizaciones\n</code></pre>"},{"location":"codigo/#parametros-y-ejecucion-de-la-simulacion","title":"Par\u00e1metros y ejecuci\u00f3n de la simulaci\u00f3n","text":"<pre><code>N = 4\nJ = 1.0\ng = 1.0\n\nH = hamiltoniano(N, J, g)\npsi0 = estado_inicial(N)\ntiempos = np.linspace(0, 5, 100)\nestados = evolucion(psi0, H, tiempos)\nmagnetizaciones = magnetizacion_z(estados, N)\n</code></pre>"},{"location":"codigo/#implementacion-en-c","title":"Implementaci\u00f3n en C++","text":""},{"location":"codigo/#matrizcpp","title":"Matriz.cpp","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include \"Matriz.hpp\"\n#include &lt;omp.h&gt;\nMatriz::Matriz(int filas_,int columnas_): filas(filas_), columnas(columnas_),data(filas*columnas, {0.0,0.0}){}\nMatriz::Matriz(int filas_,int columnas_,const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores): filas(filas_),columnas(columnas_), data(valores){}\nMatriz Matriz::operator+(const Matriz &amp;obj) const {\n    Matriz newMatriz(filas,columnas);\n    #pragma omp parallel for\n    for (int i=0; i &lt;filas;++i){\n        for (int j=0; j &lt;columnas;++j){\n        newMatriz(i,j)=(*this)(i,j)+obj(i,j);\n        }\n    }\n    return newMatriz;\n}\n\nint Matriz::sizef() const {\n    return filas;\n}\nint Matriz::sizec() const {\n    return columnas;\n}\nstd::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j){\n    return data[i*columnas+j];\n}\nconst std::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j) const{\n        return data[i*columnas+j];\n}\nconst std::vector&lt;std::complex&lt;double&gt;&gt;&amp; Matriz::datos() const {\n    return data;\n}\nMatriz Matriz::operator*(const Matriz &amp;obj) const{\n     Matriz newMatriz(filas,obj.sizec());\n     #pragma omp parallel for\n     for (int i = 0; i &lt; filas; ++i){\n            for (int j = 0; j &lt; obj.sizec(); ++j){\n                    for (int k = 0; k &lt; columnas; ++k){\n                        newMatriz(i, j) += (*this)(i, k) * obj(k, j);\n            }\n        }\n     }\n         return newMatriz;\n}\nMatriz Matriz::operator*(const std::complex&lt;double&gt;&amp; escalar) const{\n    Matriz newMatriz(filas,columnas);\n    #pragma omp parallel for\n    for (int i=0; i &lt; filas; ++i){\n        for (int j = 0; j &lt; columnas; ++j){\n            newMatriz(i,j)=(*this)(i, j) * escalar;\n        }\n    }\n    return newMatriz;\n}\nMatriz Matriz::tensor(const Matriz &amp;obj) const {\n    int m = filas;\n    int n = columnas;\n    int p = obj.sizef();\n    int q = obj.sizec();\n    Matriz newMatriz(m*p,n*q);\n    #pragma omp parallel for collapse(2)\n    for (int i=0;i&lt;m;++i){\n        for (int j=0;j&lt;n;++j){\n            for (int k=0;k&lt;p;++k){\n                for (int l=0;l&lt;q;++l){\n                    newMatriz(i*p+k,j*q+l)=(*this)(i,j)*obj(k,l);\n                }\n            }\n        }\n    }\n\n    return newMatriz;\n}\n</code></pre>"},{"location":"codigo/#matrizhpp","title":"Matriz.hpp","text":"<pre><code>#ifndef MATRIZ_HPP\n#define MATRIZ_HPP\n\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n\nclass Matriz {\n    private:\n        int filas, columnas;\n        std::vector&lt;std::complex&lt;double&gt;&gt; data;\n    public:\n        Matriz(int filas, int columnas, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores);\n        Matriz(int filas, int columnas);\n        Matriz operator+(const Matriz &amp;obj) const;\n        Matriz operator*(const Matriz &amp;obj) const;\n        Matriz operator*(const std::complex&lt;double&gt; &amp;escalar) const;\n        Matriz tensor(const Matriz &amp;obj) const;\n        int sizef() const;\n        int sizec() const;\n        std::complex&lt;double&gt;&amp; operator()(int i, int j);\n        const std::complex&lt;double&gt;&amp; operator()(int i, int j) const;\n        const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; datos() const;\n};\n\n#endif\n</code></pre>"},{"location":"codigo/#hamiltonianocpp","title":"hamiltoniano.cpp","text":"<pre><code>#include \"hamiltoniano.hpp\"\n#include \"pauli.hpp\" \n#include &lt;iostream&gt;\n\nHamiltoniano::Hamiltoniano(int N_): N(N_),H(1 &lt;&lt; N_, 1 &lt;&lt; N_) {\n    int dim =1&lt;&lt;N; \n    H=Matriz(dim, dim);\n}\nvoid Hamiltoniano::construir(double J, double g) {\n    int dim =1 &lt;&lt;N;\n    H=Matriz(dim,dim);\n    for (int i=0;i&lt;N;++i){\n        int ip =(i+1)%N;\n        Matriz term_zz=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});\n        for (int site=0;site&lt;N;++site){\n            if (site == i)\n                term_zz=term_zz.tensor(Pauli::Z());\n            else if (site==ip)\n                term_zz=term_zz.tensor(Pauli::Z());\n            else\n                term_zz = term_zz.tensor(Pauli::I());\n        }\n        H=H+term_zz*(-J);\n    }\n    for (int i=0;i&lt;N;++i){\n        Matriz term_x=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});\n        for (int site=0;site&lt;N;++site){\n            if (site==i)\n                term_x=term_x.tensor(Pauli::X());\n            else\n                term_x=term_x.tensor(Pauli::I());\n        }\n        H=H+term_x*(-g);\n    }\n}\n\nconst Matriz&amp; Hamiltoniano::matriz() const {\n    return H;\n}\n</code></pre>"},{"location":"codigo/#hamiltonianohpp","title":"hamiltoniano.hpp","text":"<pre><code>#ifndef HAMILTONIANO_HPP\n#define HAMILTONIANO_HPP\n#include \"Matriz.hpp\"\n#include &lt;vector&gt;\n#include &lt;complex&gt;\nclass Hamiltoniano {\nprivate:\n    Matriz H;            \n    int N;            \npublic:\n    Hamiltoniano(int N_);\n    void construir(double J, double g); \n    const Matriz&amp; matriz() const;\n};\n\n#endif\n</code></pre>"},{"location":"codigo/#maincpp","title":"main.cpp","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include \"Matriz.hpp\"\n#include \"hamiltoniano.hpp\"\n#include \"rk4.hpp\"\n#include \"pauli.hpp\"\nint main(){\n    double J=1.0;\n    double g=1.0;\n    double tF=2.0;\n    double h=0.0001;\n    int spin = 3;\n    int n=100;\n        int dim = 1 &lt;&lt; spin; \n    std::vector&lt;std::complex&lt;double&gt;&gt; inicial(dim, {1.0, 0.0});\n    Matriz phi0(dim,1,inicial);\n    Matriz phicopy(dim,1);\n    Hamiltoniano H_(spin);\n    H_.construir(J,g);\n    Matriz H=H_.matriz();\n    rk4 rk4(H,h);\n    double contador=0;\n    while (contador &lt;=tF){\n        phicopy=rk4.aplicar(phi0); \n        std::cout&lt;&lt;\"t = \"&lt;&lt; contador&lt;&lt; std::endl;\n        for (int i=0;i&lt; phicopy.sizef();++i){\n                std::cout &lt;&lt; phicopy(i,0)&lt;&lt; std::endl;\n            }\n        std::cout &lt;&lt; std::endl;\n        contador+=h;\n        phi0=phicopy;\n    }\n    phicopy=rk4.direct(phi0,n,tF);\n    for (int i=0;i&lt;phicopy.sizef();++i){\n            std::cout&lt;&lt;phicopy(i,0)&lt;&lt;std::endl;\n        }\n        std::cout &lt;&lt; std::endl;\n\n    return 0;\n    }\n</code></pre>"},{"location":"codigo/#paulicpp","title":"pauli.cpp","text":"<pre><code>#include \"pauli.hpp\"\n\nMatriz Pauli::I(){\n    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0)});\n}\nMatriz Pauli::X(){\nreturn Matriz(2,2,{std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0)});\n}\nMatriz Pauli::Z(){\n    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(-1,0)});\n</code></pre>"},{"location":"codigo/#paulihpp","title":"pauli.hpp","text":"<pre><code>\n#ifndef PAULI_H\n#define PAULI_H\n#include \"Matriz.hpp\"\n\nclass Pauli {\npublic:\n    static Matriz I();\n    static Matriz X();\n    static Matriz Z();\n};\n\n#endif\n</code></pre>"},{"location":"codigo/#rk4cpp","title":"rk4.cpp","text":"<pre><code>\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include \"Matriz.hpp\"\n#include \"rk4.hpp\"\n\nrk4::rk4(const Matriz&amp; Hamiltoniano, double paso):H(Hamiltoniano),h(paso) {}\nMatriz rk4::aplicar(const Matriz &amp;phi0) const{\n    std::complex&lt;double&gt; z(0.0, -1.0);\n    std::complex&lt;double&gt; coef= z*h;\n    Matriz k1(phi0.sizef(),1),k2(phi0.sizef(),1),k3(phi0.sizef(),1),k4(phi0.sizef(),1);\n    k1=H*phi0*coef;\n    k2=H*(phi0+k1*0.5)*coef;\n    k3=H*(phi0+k2*0.5)*coef;\n    k4=H*(phi0+k3)*coef;\n    return phi0+(k1+k2*2+k3*2+k4)*(1.0/6.0);\n}\nMatriz rk4::direct(const Matriz&amp; phi0,int &amp;n,double &amp;t) const{\n        std::complex&lt;double&gt; z(0.0, -1.0);\n     Matriz phi1(phi0.sizef(), 1);\n         Matriz identidad(H.sizef(), H.sizec());\n        for (int i = 0; i &lt; H.sizef(); ++i) {\n            identidad(i, i) = {1.0, 0.0};\n        }\n        Matriz suma = identidad;\n        Matriz potenciaH = identidad;\n        std::complex&lt;double&gt; coef = 1.0;  // Coeficiente factorial\n        for (int k=1;k&lt;=n;++k){\n            potenciaH = potenciaH*H;\n            coef /= static_cast&lt;double&gt;(k);\n            suma =suma+potenciaH*(coef*std::pow(z*t,k));\n        }\n\n        phi1 = suma*phi0;\n        return phi1;\n}\n</code></pre>"},{"location":"codigo/#rk4hpp","title":"rk4.hpp","text":"<pre><code>\n#ifndef RK4_HPP\n#define RK4_HPP\n\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include \"Matriz.hpp\"\n\nclass rk4 {\nprivate:\n    Matriz H;\n    double h;\npublic:\n    rk4(const Matriz&amp; Hamiltoniano, double paso);\n    Matriz aplicar(const Matriz &amp;phi0) const;\n    Matriz direct(const Matriz &amp;phi0, int &amp;n,double &amp;t) const;\n};\n\n#endif\n</code></pre>"},{"location":"resultados/","title":"Resultados","text":"<p>A continuaci\u00f3n se presenta la evoluci\u00f3n temporal de los valores esperados \u27e8\u03c3\u1dbb\u27e9 para cada sitio del modelo de Ising cu\u00e1ntico unidimensional:</p> <p> </p> <p>Como se puede observar, el comportamiento de los espines var\u00eda en el tiempo debido a la din\u00e1mica cu\u00e1ntica gobernada por el Hamiltoniano total del sistema.</p>"}]}