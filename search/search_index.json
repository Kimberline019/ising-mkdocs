{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido","text":""},{"location":"#modelo-de-ising-cuantico-unidimensional-en-una-grilla-de-n-espines","title":"Modelo de Ising cu\u00e1ntico unidimensional en una grilla de \\( N \\) espines","text":"<p>El modelo de Ising cu\u00e1ntico es una extensi\u00f3n natural del modelo de Ising cl\u00e1sico, uno de los m\u00e1s simples y famosos para describir materiales magn\u00e9ticos, propuesto por Ernst Ising en 1925.</p> <p>Para el modelo cl\u00e1sico, se tiene una red donde cada punto contiene un esp\u00edn que puede tomar solo dos valores \\( s_i = \\pm1 \\). El sistema busca minimizar su energ\u00eda total dependiendo de c\u00f3mo interact\u00faan los espines. Para medir la energ\u00eda total de una configuraci\u00f3n se usa el siguiente Hamiltoniano cl\u00e1sico:</p> \\[ H = -J \\sum_{\\langle i, j\\rangle} s_i s_j - h \\sum_{i} s_i \\] <p>Donde:</p> <ul> <li>\\( s_i = \\pm 1 \\) es el esp\u00edn cl\u00e1sico en el sitio \\( i \\),</li> <li>\\( J \\) es la constante de acoplamiento:</li> <li>\\( J &gt; 0 \\): favorece que los espines se alineen (ferromagnetismo),</li> <li>\\( J &lt; 0 \\): favorece que se desalineen (antiferromagnetismo),</li> <li>\\( h \\) es el campo magn\u00e9tico externo cl\u00e1sico.</li> </ul>"},{"location":"#hamiltoniano-del-modelo-cuantico","title":"Hamiltoniano del modelo cu\u00e1ntico","text":"<p>El modelo de Ising cu\u00e1ntico permite estudiar el comportamiento colectivo de muchos espines cu\u00e1nticos en una red, donde los espines pueden interactuar entre s\u00ed \\( \\text{(alinearse o desalinearse)} \\). El Hamiltoniano del modelo cu\u00e1ntico 1D con campo transversal (perpendicular al eje de los espines) es:</p> \\[ \\hat{H} = -J\\sum_{i=1}^{N-1} \\hat{\\sigma}_{i}^{z} \\hat{\\sigma}_{i + 1}^z - g \\sum_{i = 1}^N \\hat{\\sigma}_{i}^x \\] <p>Donde:</p> <ul> <li>\\( J \\): escala energ\u00e9tica de la interacci\u00f3n ferromagn\u00e9tica,</li> <li>\\( g \\): intensidad del campo transversal cu\u00e1ntico,</li> <li>\\( \\hat{\\sigma}_{i}^{z} \\): matriz de Pauli-Z que mide si un esp\u00edn est\u00e1 en \\( \\uparrow \\) o \\( \\downarrow \\),</li> <li>\\( \\hat{\\sigma}_{i}^{x} \\): matriz de Pauli-X que representa la posibilidad de cambio de estado \\( \\left(\\uparrow \\leftrightarrow \\downarrow \\right) \\).</li> </ul>"},{"location":"#matrices-de-pauli","title":"Matrices de Pauli","text":"\\[ \\sigma_x = \\begin{pmatrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{pmatrix}, \\quad \\sigma_y = \\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}, \\quad \\sigma_z = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{pmatrix}, \\quad I = \\begin{pmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"#interpretacion-fisica-del-hamiltoniano","title":"Interpretaci\u00f3n f\u00edsica del Hamiltoniano","text":"<p>Primer t\u00e9rmino \\( \\hat{\\sigma}_{i}^{z} \\hat{\\sigma}_{i+1}^{z} \\): - Representa la interacci\u00f3n entre espines vecinos. - Si est\u00e1n alineados \\( (\\uparrow\\uparrow \\text{ o } \\downarrow\\downarrow) \\), da baja energ\u00eda. - Si est\u00e1n opuestos \\( (\\uparrow\\downarrow \\text{ o } \\downarrow\\uparrow) \\), da mayor energ\u00eda.</p> <p>Segundo t\u00e9rmino \\( \\hat{\\sigma}_{i}^x \\): - Representa la acci\u00f3n de un campo en la direcci\u00f3n \\( x \\), - Introduce fluctuaciones cu\u00e1nticas que permiten que los espines cambien de estado.</p>"},{"location":"#competencia-entre-orden-y-fluctuacion","title":"Competencia entre orden y fluctuaci\u00f3n","text":"<ul> <li>Cuando \\( h = 0 \\): s\u00f3lo hay interacci\u00f3n entre espines \u2192 tienden a estar alineados \u2192 estado ferromagn\u00e9tico.</li> <li>Cuando \\( J = 0 \\): los espines siguen solo el campo externo \u2192 act\u00faan independientemente \u2192 estado paramagn\u00e9tico.</li> <li>Cuando \\( h \\sim J \\): hay un equilibrio \u2192 aparece una transici\u00f3n cu\u00e1ntica de fase.</li> </ul>"},{"location":"#representacion-en-mecanica-cuantica","title":"Representaci\u00f3n en mec\u00e1nica cu\u00e1ntica","text":"<p>Cada esp\u00edn vive en un espacio de dimensi\u00f3n 2 ( \\( \\uparrow \\) o \\( \\downarrow \\) ). Una cadena de \\( N \\) espines tiene un espacio de estados de dimensi\u00f3n \\( 2^N \\). Por ejemplo:</p> <ul> <li>\\( N = 1 \\): estados = \\( \\{ \\uparrow, \\downarrow \\} \\)</li> <li>\\( N = 2 \\): estados = \\( \\{ \\uparrow\\uparrow, \\uparrow\\downarrow, \\downarrow\\uparrow, \\downarrow\\downarrow \\} \\)</li> <li>\\( N = 3 \\): estados = \\( \\{ \\uparrow\\uparrow\\uparrow, \\uparrow\\uparrow\\downarrow, \\ldots, \\downarrow\\downarrow\\downarrow \\} \\Rightarrow 8 \\) posibles</li> </ul> <p>El Hamiltoniano es entonces una matriz de dimensi\u00f3n \\( 2^N \\times 2^N \\) que describe todas las interacciones posibles del sistema.</p>"},{"location":"#dinamica-cuantica","title":"Din\u00e1mica cu\u00e1ntica","text":"<p>A diferencia del modelo cl\u00e1sico, en el modelo cu\u00e1ntico el Hamiltoniano tambi\u00e9n describe la evoluci\u00f3n temporal del estado del sistema:</p> \\[ \\frac{\\partial |\\psi(t)\\rangle}{\\partial t} = -i\\hat{H} |\\psi(t)\\rangle \\] <p>La soluci\u00f3n de esta ecuaci\u00f3n es:</p> \\[ |\\psi(t)\\rangle = e^{-i \\hat{H}(t - t_0)} |\\psi(t = t_0)\\rangle \\] <p>Este formalismo permite estudiar:</p> <ul> <li>Din\u00e1mica de espines y correlaciones en el tiempo,</li> <li>Entrelazamiento cu\u00e1ntico,</li> <li>Simulaci\u00f3n cu\u00e1ntica de materiales y algoritmos cu\u00e1nticos.</li> </ul>"},{"location":"#implementacion-numerica","title":"Implementaci\u00f3n num\u00e9rica","text":"<p>Para implementar este modelo en c\u00f3digo (por ejemplo, en C++), es necesario:</p> <ul> <li>Representar las matrices de Pauli y la Identidad como matrices <code>2x2</code>.</li> <li>Usar el producto tensorial para construir las matrices que act\u00faan sobre el espacio completo de dimensi\u00f3n \\( 2^N \\).</li> <li>Construir el Hamiltoniano sumando los t\u00e9rminos de interacci\u00f3n y campo.</li> <li>Diagonalizar el Hamiltoniano para obtener autovalores y autovectores.</li> <li>Evolucionar el estado en el tiempo con \\( e^{-iHt} \\mid \\psi(0) \\rangle \\).</li> </ul> <p>Este procedimiento es computacionalmente costoso para \\( N &gt; 10 \\), por lo que se aplica principalmente a sistemas peque\u00f1os.</p>"},{"location":"codigo/","title":"C\u00f3digo del modelo de Ising cu\u00e1ntico en Python","text":"<p>Este apartado presenta la implementaci\u00f3n completa del modelo de Ising cu\u00e1ntico unidimensional con campo transversal, un sistema fundamental en la f\u00edsica de muchos cuerpos. A continuaci\u00f3n, se explica cada parte del c\u00f3digo que simula su din\u00e1mica cu\u00e1ntica.</p>"},{"location":"codigo/#hamiltoniano-del-modelo","title":"Hamiltoniano del modelo","text":"<p>El Hamiltoniano est\u00e1 dado por:</p> \\[ H = -J \\sum_{i=1}^{N-1} \\sigma^z_i \\sigma^z_{i+1} - g \\sum_{i=1}^N \\sigma^x_i \\] <p>donde: - \\( \\sigma^x \\) y \\( \\sigma^z \\) son matrices de Pauli, - \\( J \\) es la constante de acoplamiento entre espines vecinos, - \\( g \\) es la intensidad del campo transversal, - \\( N \\) es el n\u00famero total de espines en la cadena.</p>"},{"location":"codigo/#implementacion-del-modelo-en-python","title":"Implementaci\u00f3n del modelo en Python","text":"<pre><code>import numpy as np\nfrom functools import reduce\nfrom scipy.linalg import expm\n</code></pre>"},{"location":"codigo/#matrices-de-pauli-y-matriz-identidad","title":"Matrices de Pauli y matriz identidad","text":"<pre><code>I = np.eye(2)\nsx = np.array([[0, 1], [1, 0]])   # \u03c3_x\nsz = np.array([[1, 0], [0, -1]])  # \u03c3_z\n</code></pre>"},{"location":"codigo/#producto-tensorial","title":"Producto tensorial","text":"<pre><code>def producto_tensorial(matrices):\n    return reduce(np.kron, matrices)\n</code></pre>"},{"location":"codigo/#construccion-del-hamiltoniano","title":"Construcci\u00f3n del Hamiltoniano","text":"<pre><code>def hamiltoniano(N, J, g):\n    H = np.zeros((2**N, 2**N))\n\n    # T\u00e9rmino de interacci\u00f3n \u03c3^z_i \u03c3^z_{i+1}\n    for i in range(N - 1):\n        op_z = [I] * N\n        op_z[i] = sz\n        op_z[i + 1] = sz\n        H -= J * producto_tensorial(op_z)\n\n    # T\u00e9rmino de campo transversal \u03c3^x_i\n    for i in range(N):\n        op_x = [I] * N\n        op_x[i] = sx\n        H -= g * producto_tensorial(op_x)\n\n    return H\n</code></pre>"},{"location":"codigo/#estado-inicial-todos-los-espines-arriba","title":"Estado inicial: todos los espines arriba","text":"<pre><code>def estado_inicial(N):\n    arriba = np.array([[1], [0]])  # Estado |0\u27e9\n    return producto_tensorial([arriba] * N)\n</code></pre>"},{"location":"codigo/#evolucion-temporal-del-sistema","title":"Evoluci\u00f3n temporal del sistema","text":"<pre><code>def evolucion(psi0, H, tiempos):\n    estados = []\n    for t in tiempos:\n        U = expm(-1j * H * t)\n        psi_t = U @ psi0\n        estados.append(psi_t)\n    return estados\n</code></pre>"},{"location":"codigo/#operador-z-en-el-sitio-i","title":"Operador \u03c3^z en el sitio i","text":"<pre><code>def sigma_z_en_i(N, i):\n    ops = [I] * N\n    ops[i] = sz\n    return producto_tensorial(ops)\n</code></pre>"},{"location":"codigo/#magnetizacion-langle-sigmaz_i-rangle-t","title":"Magnetizaci\u00f3n \\( \\langle \\sigma^z_i \\rangle (t) \\)","text":"<pre><code>def magnetizacion_z(estados, N):\n    magnetizaciones = np.zeros((len(estados), N))\n    for t_idx, psi in enumerate(estados):\n        for i in range(N):\n            Sz_i = sigma_z_en_i(N, i)\n            magnetizaciones[t_idx, i] = np.real((psi.conj().T @ Sz_i @ psi).item())\n    return magnetizaciones\n</code></pre>"},{"location":"codigo/#parametros-y-ejecucion-de-la-simulacion","title":"Par\u00e1metros y ejecuci\u00f3n de la simulaci\u00f3n","text":"<pre><code>N = 4\nJ = 1.0\ng = 1.0\n\nH = hamiltoniano(N, J, g)\npsi0 = estado_inicial(N)\ntiempos = np.linspace(0, 5, 100)\nestados = evolucion(psi0, H, tiempos)\nmagnetizaciones = magnetizacion_z(estados, N)\n</code></pre>"},{"location":"codigo/#implementacion-en-c","title":"Implementaci\u00f3n en C++","text":""},{"location":"codigo/#matrizcpp","title":"Matriz.cpp","text":"<p>Este c\u00f3digo implementa una clase Matriz que representa matrices de n\u00fameros complejos y define operaciones fundamentales como suma, multiplicaci\u00f3n matricial, multiplicaci\u00f3n por escalar y producto tensorial, todas optimizadas con paralelizaci\u00f3n mediante OpenMP; su prop\u00f3sito dentro del modelo de Ising cu\u00e1ntico unidimensional es facilitar la construcci\u00f3n eficiente del Hamiltoniano a trav\u00e9s de productos tensoriales de matrices de Pauli, as\u00ed como la evoluci\u00f3n del estado cu\u00e1ntico mediante multiplicaciones repetidas de matrices durante la integraci\u00f3n num\u00e9rica de la ecuaci\u00f3n de Schr\u00f6dinger.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include \"Matriz.hpp\"\n#include &lt;omp.h&gt;\nMatriz::Matriz(int filas_,int columnas_): filas(filas_), columnas(columnas_),data(filas*columnas, {0.0,0.0}){}\nMatriz::Matriz(int filas_,int columnas_,const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores): filas(filas_),columnas(columnas_), data(valores){}\nMatriz Matriz::operator+(const Matriz &amp;obj) const {\n    Matriz newMatriz(filas,columnas);\n    #pragma omp parallel for\n    for (int i=0; i &lt;filas;++i){\n        for (int j=0; j &lt;columnas;++j){\n        newMatriz(i,j)=(*this)(i,j)+obj(i,j);\n        }\n    }\n    return newMatriz;\n}\n\nint Matriz::sizef() const {\n    return filas;\n}\nint Matriz::sizec() const {\n    return columnas;\n}\nstd::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j){\n    return data[i*columnas+j];\n}\nconst std::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j) const{\n        return data[i*columnas+j];\n}\nconst std::vector&lt;std::complex&lt;double&gt;&gt;&amp; Matriz::datos() const {\n    return data;\n}\nMatriz Matriz::operator*(const Matriz &amp;obj) const{\n     Matriz newMatriz(filas,obj.sizec());\n     #pragma omp parallel for\n     for (int i = 0; i &lt; filas; ++i){\n            for (int j = 0; j &lt; obj.sizec(); ++j){\n                    for (int k = 0; k &lt; columnas; ++k){\n                        newMatriz(i, j) += (*this)(i, k) * obj(k, j);\n            }\n        }\n     }\n         return newMatriz;\n}\nMatriz Matriz::operator*(const std::complex&lt;double&gt;&amp; escalar) const{\n    Matriz newMatriz(filas,columnas);\n    #pragma omp parallel for\n    for (int i=0; i &lt; filas; ++i){\n        for (int j = 0; j &lt; columnas; ++j){\n            newMatriz(i,j)=(*this)(i, j) * escalar;\n        }\n    }\n    return newMatriz;\n}\nMatriz Matriz::tensor(const Matriz &amp;obj) const {\n    int m = filas;\n    int n = columnas;\n    int p = obj.sizef();\n    int q = obj.sizec();\n    Matriz newMatriz(m*p,n*q);\n    #pragma omp parallel for collapse(2)\n    for (int i=0;i&lt;m;++i){\n        for (int j=0;j&lt;n;++j){\n            for (int k=0;k&lt;p;++k){\n                for (int l=0;l&lt;q;++l){\n                    newMatriz(i*p+k,j*q+l)=(*this)(i,j)*obj(k,l);\n                }\n            }\n        }\n    }\n\n    return newMatriz;\n}\n</code></pre>"},{"location":"codigo/#matrizhpp","title":"Matriz.hpp","text":"<pre><code>\n#ifndef MATRIZ_HPP \n#define MATRIZ_HPP \n\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n/**\n * @brief Representa matrices. \n * Simplifica c\u00e1lculos con matrices mediante operadores, lo que evita for loops expl\u00edcitos en el resto del c\u00f3digo.\n * Almacena las dimensiones de la matriz en variables int  y sus datos en un std::vector&lt;std::complex&lt;double&gt;&gt;\n */\nclass Matriz {\n    private:\n        int filas, columnas;\n        std::vector&lt;std::complex&lt;double&gt;&gt; data;\n    public:\n        /**\n        * @brief Constructor personalizado que representa una matriz con el tama\u00f1o y datos dados.\n        * Ejemplo de uso:\n        * @code\n        *  Matriz B(2,2,({1,0},{0,0},{0,1},{0,1});\n        * @endcode\n        *\n        * @param filas  N\u00famero de filas.\n        * @param columnas  N\u00famero de columnas.\n        * @param vector complejo con los datos aplanados de la matriz.\n        */\n        Matriz(int filas, int columnas, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores);\n        /**\n        * @brief Constructor personalizado que representa una matriz no inicializada con el tama\u00f1o dado.\n        *\n        * Ejemplo de uso:\n        * @code\n        * Matriz A(2,2);\n        * @endcode\n        *\n        * @param filas N\u00famero de filas.\n        * @param columnas N\u00famero de columnas.\n        */\n        Matriz(int filas, int columnas);\n         /**\n         * @brief Realiza la suma de dos matrices.\n         *\n         * Ejemplo de uso:\n         * @code\n         * Matriz C=A+B;\n         * @endcode\n         *\n         * @param &amp;obj Matriz a la derecha de la suma.\n         * @return La suma de ambas matrices.\n         */\n        Matriz operator+(const Matriz &amp;obj) const;\n                 /**\n                 * @brief Realiza el producto entre dos matrices.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * Matriz C=A*B;\n                 * @endcode\n                 *\n                 * @param &amp;obj Matriz a la derecha del producto.\n                 * @return El producto matricial.\n                 */\n        Matriz operator*(const Matriz &amp;obj) const;\n                 /**\n                 * @brief Realiza el producto escalar.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * Matriz C=A*b;\n                 * @endcode\n                 *\n                 * @param &amp;escalar escalar por el que se va a multiplicar (debe siempre estar a la derecha de la matriz).\n                 * @return Resultado del producto.\n                 */\n        Matriz operator*(const std::complex&lt;double&gt; &amp;escalar) const;\n         /**\n                 * @brief Realiza el producto tensorial.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * Matriz C=A.tensor(B);\n                 * @endcode\n                 *\n                 * @param &amp;obj Matriz derecha por la que se realizar\u00e1 el producto tensorial.\n                 * @return Matriz resultado del producto tensorial.\n                 */\n        Matriz tensor(const Matriz &amp;obj) const;\n         /**\n                 * @brief Da la cantidad de filas de la matriz.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * int b=A.sizef();\n         * //b=2\n                 * @endcode\n                 *\n                 * @return N\u00famero de filas de la matriz.\n                 */\n        int sizef() const;\n         /**\n                 * @brief Da la cantidad de columnas de la matriz.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * int b=A.sizec();\n                 * //b=2\n                 * @endcode\n                 *\n                 * @return N\u00famero de columnas de la matriz.\n                 */\n        int sizec() const;\n         /**\n                 * @brief Permite accesar un dato de la matriz aplanada de forma intuitiva para aplicaciones de la clase.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * std::complex&lt;double&gt;&gt; b=A(2,2);\n                 * //b={1.0,0.0}\n                 * @endcode\n                 *\n         * @param i Fila del dato a accesar.\n         * @param j Columna del dato a accesar.\n                 * @return Dato en la posici\u00f3n (i,j) de la matriz.\n                 */\n        std::complex&lt;double&gt;&amp; operator()(int i, int j);\n         /* @brief Permite accesar un dato de la matriz aplanada de forma intuitiva para aplicaciones externas.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * std::complex&lt;double&gt;&gt; b=A(2,2);\n                 * //b={1.0,0.0}\n                 * @endcode\n                 *\n                 * @param i Fila del dato a accesar.\n                 * @param j Columna del dato a accesar.\n                 * @return Dato en la posici\u00f3n (i,j) de la matriz.\n                 */\n        const std::complex&lt;double&gt;&amp; operator()(int i, int j) const;\n         /* @brief Devuelve el vector complejo que almacena los datos de la matriz.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * std::vector&lt;std::complex&lt;double&gt;&gt; b=A.datos()\n                 * //b=({1,0},{0,0},{0,1},{0,1})\n                 * @endcode\n                 *\n                 * @param i Fila del dato a accesar.\n                 * @param j Columna del dato a accesar.\n                 * @return Dato en la posici\u00f3n (i,j) de la matriz.\n                 */\n        const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; datos() const;\n                 /* @brief Devuelve la norma de un vector columna.\n                 *\n                 * Ejemplo de uso:\n                 * @code\n                 * double b=A.norma()\n                 * //b=sqrt(5)\n                 * @endcode\n                 *\n                 * @return Norma del vector.\n                 */\n        double norma() const;\n};\n\n</code></pre>"},{"location":"codigo/#hamiltonianocpp","title":"hamiltoniano.cpp","text":"<p>El archivo hamiltoniano.cpp define una clase Hamiltoniano que construye la matriz Hamiltoniana del modelo de Ising cu\u00e1ntico unidimensional en una red de $$ ( N )$$ espines, empleando productos tensoriales de matrices de Pauli. El t\u00e9rmino de interacci\u00f3n $$ ( -J \\sum_i \\sigma^z_i \\sigma^z_{i+1} )$$ se implementa mediante ciclos que insertan dos matrices$$ (\\sigma^z)$$ en las posiciones correspondientes y matrices identidad en los sitios restantes, considerando condiciones peri\u00f3dicas. El t\u00e9rmino de campo transversal $$ ( -g \\sum_i \\sigma^x_i )$$  se construye de forma similar, insertando$$ (\\sigma^x)$$  en la posici\u00f3n adecuada. La matriz resultante $$ ( \\hat{H} )$$ es de dimensi\u00f3n \\(\\(( 2^N \\times 2^N )\\)\\) y se guarda internamente para su posterior uso en la evoluci\u00f3n din\u00e1mica del sistema.</p> <pre><code>#include \"hamiltoniano.hpp\"\n#include \"pauli.hpp\" \n#include &lt;iostream&gt;\n\nHamiltoniano::Hamiltoniano(int N_): N(N_),H(1 &lt;&lt; N_, 1 &lt;&lt; N_) {\n    int dim =1&lt;&lt;N; \n    H=Matriz(dim, dim);\n}\nvoid Hamiltoniano::construir(double J, double g) {\n    int dim =1 &lt;&lt;N;\n    H=Matriz(dim,dim);\n    for (int i=0;i&lt;N;++i){\n        int ip =(i+1)%N;\n        Matriz term_zz=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});\n        for (int site=0;site&lt;N;++site){\n            if (site == i)\n                term_zz=term_zz.tensor(Pauli::Z());\n            else if (site==ip)\n                term_zz=term_zz.tensor(Pauli::Z());\n            else\n                term_zz = term_zz.tensor(Pauli::I());\n        }\n        H=H+term_zz*(-J);\n    }\n    for (int i=0;i&lt;N;++i){\n        Matriz term_x=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});\n        for (int site=0;site&lt;N;++site){\n            if (site==i)\n                term_x=term_x.tensor(Pauli::X());\n            else\n                term_x=term_x.tensor(Pauli::I());\n        }\n        H=H+term_x*(-g);\n    }\n}\n\nconst Matriz&amp; Hamiltoniano::matriz() const {\n    return H;\n}\n</code></pre>"},{"location":"codigo/#hamiltonianohpp","title":"hamiltoniano.hpp","text":"<pre><code>\n#include \"Matriz.hpp\"\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n/**\n * @brief Esta clase se encarga de realizar las operaciones necesarias para construir el Hamiltoniano del sistema a partir de los valores datos.\n *Almacena la matriz del Hamiltoniano y la cantidad de espines del sistema.\n * \n */\nclass Hamiltoniano {\nprivate:\n    Matriz H;            \n    int N;            \npublic:\n    /**\n    * @brief Constructor personalizado que crea una matriz sin inicializar de las dimensiones del Hamiltoniano del sistema.\n    *\n    * Ejemplo de uso:\n    * @code\n    * Hamiltoniano H_(espin);\n    * @endcode\n    */\n    Hamiltoniano(int N_);\n    /**\n    * @brief Realiza los productos tensoriales necesarios para crear la matriz del Hamiltoniano del sistema y los almacena en los datos de la instancia.\n    *\n    * Ejemplo de uso:\n    * @code\n    * H_,construir(J,g);\n    * @endcode\n    *\n    * @param J dato de la escala energ\u00e9tica de la interacci\u00f3n ferromagn\u00e9tica.\n    * @param g dato del par\u00e1metro energ\u00e9tico del campo transversal.\n    */\n    void construir(double J, double g); \n        /**\n    * @brief Devuelve el hamiltoniano del que la clase almacena.\n    *\n    * Ejemplo de uso:\n    * @code\n    * H=H_,matriz();\n    * @endcode\n    *\n    * @return Matriz con el hamiltoniano de la clase.\n    */\n    const Matriz&amp; matriz() const;\n};\n\n</code></pre>"},{"location":"codigo/#maincpp","title":"main.cpp","text":"<p>El archivo main.cpp realiza la simulaci\u00f3n num\u00e9rica de la din\u00e1mica del modelo de Ising  a trav\u00e9s de un enfoque de evoluci\u00f3n temporal. El usuario ingresa el n\u00famero de hilos a utilizar mediante OpenMP para aprovechar la paralelizaci\u00f3n del c\u00e1lculo. A partir de un estado inicial puro, se construye la matriz Hamiltoniana  \\(\\hat{H}\\)  del sistema utilizando productos tensoriales de matrices de Pauli y se resuelve la ecuaci\u00f3n de Schr\u00f6dinger dependiente del tiempo utilizando el m\u00e9todo de Runge-Kutta de cuarto orden, implementado en la clase rk4. Adem\u00e1s, se eval\u00faa la evoluci\u00f3n unitaria exacta mediante una expansi\u00f3n de Taylor truncada, permitiendo comparar y validar el m\u00e9todo num\u00e9rico. Finalmente, se mide el tiempo total de ejecuci\u00f3n para evaluar el desempe\u00f1o computacional seg\u00fan el n\u00famero de hilos empleados, lo cual es esencial para el an\u00e1lisis de aceleraci\u00f3n (speedup) en c\u00e1lculos paralelos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include \"Matriz.hpp\"\n#include \"hamiltoniano.hpp\"\n#include \"rk4.hpp\"\n#include \"pauli.hpp\"\n#include &lt;omp.h&gt;\n#include &lt;sys/time.h&gt;\n\ndouble seconds() {\n    struct timeval tmp;\n    gettimeofday(&amp;tmp, nullptr);\n    return tmp.tv_sec + tmp.tv_usec * 1e-6;\n}\n\n\nint main(){\n    double J=1.0;\n    double g=1.0;\n    double tF=2.0;\n    double h=0.0001;\n    int spin = 3;\n    int n=100;\n\n   int num_threads;\n    std::cout &lt;&lt; \"Ingrese el n\u00famero de hilos a usar: \";\n    std::cin &gt;&gt; num_threads;\n    omp_set_num_threads(num_threads); \n\n\n        int dim = 1 &lt;&lt; spin; \n    std::vector&lt;std::complex&lt;double&gt;&gt; inicial(dim, {1.0, 0.0});\n    Matriz phi0(dim,1,inicial);\n    Matriz phicopy(dim,1);\n\n    Hamiltoniano H_(spin);\n    H_.construir(J,g);\n    Matriz H=H_.matriz();\n\n    rk4 rk4(H,h);\n\n    double time_start = seconds();\n\n    double contador=0;\n    while (contador &lt;=tF){\n        phicopy=rk4.aplicar(phi0); \n        std::cout&lt;&lt;\"t = \"&lt;&lt; contador&lt;&lt; std::endl;\n        for (int i=0;i&lt; phicopy.sizef();++i){\n                std::cout &lt;&lt; phicopy(i,0)&lt;&lt; std::endl;\n            }\n        std::cout &lt;&lt; std::endl;\n        contador+=h;\n        phi0=phicopy;\n    }\n    phicopy=rk4.direct(phi0,n,tF);\n    for (int i=0;i&lt;phicopy.sizef();++i){\n            std::cout&lt;&lt;phicopy(i,0)&lt;&lt;std::endl;\n        }\n        std::cout &lt;&lt; std::endl;\n\n    double time_end = seconds();\n    std::cout &lt;&lt; \"Tiempo de ejecuci\u00f3n: \" &lt;&lt; (time_end - time_start) &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"N\u00famero de hilos utilizados: \" &lt;&lt; num_threads &lt;&lt; std::endl;\n    return 0;\n    }\n</code></pre>"},{"location":"codigo/#paulicpp","title":"pauli.cpp","text":"<p>El archivo $$ \\texttt{pauli.cpp}$$ define funciones est\u00e1ticas de la clase Pauli que retornan las matrices de Pauli \\(\\(( \\hat{I} )\\)\\), \\(4( \\hat{\\sigma}^x )\\)$  y $$ ( \\hat{\\sigma}^z )$$  representadas como objetos de la clase Matriz. Estas matrices son fundamentales en la construcci\u00f3n del Hamiltoniano del modelo de Ising cu\u00e1ntico unidimensional, ya que \\(\\(( \\hat{\\sigma}^z )\\)\\)  se utiliza para modelar la interacci\u00f3n entre espines vecinos, mientras que $$ ( \\hat{\\sigma}^x )$$ representa el efecto del campo magn\u00e9tico transversal. La matriz identidad \\(\\(( \\hat{I} )\\)\\) se emplea para completar los productos tensoriales cuando un operador act\u00faa sobre un sitio espec\u00edfico de la cadena de espines</p> <pre><code>#include \"pauli.hpp\"\n\nMatriz Pauli::I(){\n    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0)});\n}\nMatriz Pauli::X(){\nreturn Matriz(2,2,{std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0)});\n}\nMatriz Pauli::Z(){\n    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(-1,0)});\n</code></pre>"},{"location":"codigo/#paulihpp","title":"pauli.hpp","text":"<pre><code>\n#ifndef PAULI_H\n#define PAULI_H\n#include \"Matriz.hpp\"\n/**\n * @brief Define las matrices de Pauli usando la clase Matriz como constantes para su f\u00e1cil acceso.\n *\n */\nclass Pauli {\npublic:\n    static Matriz I();\n</code></pre>"},{"location":"codigo/#rk4cpp","title":"rk4.cpp","text":"<p>El archivo rk4.cpp implementa la clase rk4, que permite resolver num\u00e9ricamente la ecuaci\u00f3n de Schr\u00f6dinger dependiente del tiempo para un sistema cu\u00e1ntico, utilizando dos m\u00e9todos: el m\u00e9todo de Runge-Kutta de cuarto orden y una aproximaci\u00f3n directa de la evoluci\u00f3n unitaria basada en el desarrollo en serie de Taylor de la exponencial de matrices. El m\u00e9todo aplicar calcula un paso de evoluci\u00f3n temporal aplicando el algoritmo de Runge-Kutta a la funci\u00f3n de onda \\(( |\\psi(t)\\rangle )\\), con un paso de tiempo ( h ), usando la matriz Hamiltoniana \\(( \\hat{H} )\\). Por otro lado, el m\u00e9todo direct eval\u00faa directamente  \\(( e^{-i\\hat{H}t}|\\psi(0)\\rangle )\\) truncando la serie de potencias en $( n ) t\u00e9rminos, lo cual es \u00fatil para validar la precisi\u00f3n del m\u00e9todo num\u00e9rico. Ambas estrategias son fundamentales para estudiar la din\u00e1mica del modelo de Ising a partir de un estado inicial.</p> <pre><code>\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;iostream&gt;\n#include \"Matriz.hpp\"\n#include \"rk4.hpp\"\n\nrk4::rk4(const Matriz&amp; Hamiltoniano, double paso):H(Hamiltoniano),h(paso) {}\nMatriz rk4::aplicar(const Matriz &amp;phi0) const{\n    std::complex&lt;double&gt; z(0.0, -1.0);\n    std::complex&lt;double&gt; coef= z*h;\n    Matriz k1(phi0.sizef(),1),k2(phi0.sizef(),1),k3(phi0.sizef(),1),k4(phi0.sizef(),1);\n    k1=H*phi0*coef;\n    k2=H*(phi0+k1*0.5)*coef;\n    k3=H*(phi0+k2*0.5)*coef;\n    k4=H*(phi0+k3)*coef;\n    return phi0+(k1+k2*2+k3*2+k4)*(1.0/6.0);\n}\nMatriz rk4::direct(const Matriz&amp; phi0,int &amp;n,double &amp;t) const{\n        std::complex&lt;double&gt; z(0.0, -1.0);\n     Matriz phi1(phi0.sizef(), 1);\n         Matriz identidad(H.sizef(), H.sizec());\n        for (int i = 0; i &lt; H.sizef(); ++i) {\n            identidad(i, i) = {1.0, 0.0};\n        }\n        Matriz suma = identidad;\n        Matriz potenciaH = identidad;\n        std::complex&lt;double&gt; coef = 1.0;  // Coeficiente factorial\n        for (int k=1;k&lt;=n;++k){\n            potenciaH = potenciaH*H;\n            coef /= static_cast&lt;double&gt;(k);\n            suma =suma+potenciaH*(coef*std::pow(z*t,k));\n        }\n\n        phi1 = suma*phi0;\n        return phi1;\n}\n</code></pre>"},{"location":"codigo/#rk4hpp","title":"rk4.hpp","text":"<pre><code>\n#include &lt;vector&gt;\n#include &lt;complex&gt;\n#include \"Matriz.hpp\"\n/**\n * @brief Almacena los m\u00e9todos de c\u00e1lculo para el phi final.\n *\n * Sus operadores permiten calcular limpiamente el estado final de phi. Almacena el hamiltoniano del sistema y el tama\u00f1o del paso a aplicar.\n */ \nclass rk4 {\nprivate:\n    Matriz H;\n    double h;\npublic:\n    /**\n     * @brief Constructor personalizado que almacena los datos necesarios para el m\u00e9todo num\u00e9rico.\n     * Ejemplo de uso: \n     * @code \n     * rk4 metodo(H,0.001);\n     *  @endcode\n     *\n     * @param &amp;Hamiltoniano El hamiltoniano del sistema.\n     * @param Paso Tama\u00f1o del paso que aplicar\u00e1 el m\u00e9todo num\u00e9rico.\n     */\n    rk4(const Matriz&amp; Hamiltoniano, double paso);\n        /**\n     * @brief Aplica una iteraci\u00f3n del m\u00e9todo Runge-Kutta grado 4.\n     * Ejemplo de uso:\n     * @code\n     * Matriz v= metodo.aplicar(phi_0);\n     *  @endcode\n     *\n     * @param &amp;phi0 Matriz con el vector columna que almacena las condiciones de phi antes de la iteraci\u00f3n.\n     * @return &amp;phi0 Matriz con el vector columna phi en el tiempo t+h.\n     */\n    Matriz aplicar(const Matriz &amp;phi0) const;\n     /**\n     * @brief Calcula mediante series de Taylor el valor de exp(-iHt) y la aplica las condiciones iniciales de phi.\n     * Ejemplo de uso:\n     * @code\n     * Matriz v= metodo.direct(phi_0);\n     *  @endcode\n     *\n     *@param &amp;phi0 Matriz con el vector columna que almacena las condiciones de\n phi antes de la iteraci\u00f3n.\n     *@param &amp;n Entero con el n\u00famero de t\u00e9rminos que se quieren para la expansi\u00f3n de Taylor.\n     *@param &amp;t Tiempo final del sistema.\n     *@return Matriz con el vector columna con los valores finales de phi.\n     *\n     * \n     */\n\n</code></pre>"},{"location":"ising/","title":"M\u00f3dulo ising","text":"<p>Calcula el producto tensorial de una lista de matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrices</code> <code>list of np.ndarray</code> <p>Lista de matrices 2D de numpy.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Matriz resultante del producto tensorial.</p> Example <p>producto_tensorial([I, sx]).shape (4, 4)</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def producto_tensorial(matrices):\n    \"\"\"\n    Calcula el producto tensorial de una lista de matrices.\n\n    Args:\n        matrices (list of np.ndarray): Lista de matrices 2D de numpy.\n\n    Returns:\n        np.ndarray: Matriz resultante del producto tensorial.\n\n    Example:\n        &gt;&gt;&gt; producto_tensorial([I, sx]).shape\n        (4, 4)\n    \"\"\"\n    return reduce(np.kron, matrices)\n</code></pre> <p>Construye el Hamiltoniano del modelo con campo transversal.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de espines.</p> required <code>J</code> <code>float</code> <p>Constante de energ\u00eda.</p> required <code>g</code> <code>float</code> <p>Intensidad del campo transversal.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Matriz Hamiltoniana de dimensi\u00f3n 2^N x 2^N.</p> Example <p>H = hamiltoniano(4, 1.0, 1.0)</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def hamiltoniano(N, J, g):\n    \"\"\"\n    Construye el Hamiltoniano del modelo con campo transversal.\n\n    Args:\n        N (int): N\u00famero de espines.\n        J (float): Constante de energ\u00eda.\n        g (float): Intensidad del campo transversal.\n\n    Returns:\n        np.ndarray: Matriz Hamiltoniana de dimensi\u00f3n 2^N x 2^N.\n\n    Example:\n        &gt;&gt;&gt; H = hamiltoniano(4, 1.0, 1.0)\n    \"\"\"\n    H = np.zeros((2**N, 2**N), dtype=complex)\n\n    for i in range(N - 1):\n        op_z = [I] * N\n        op_z[i] = sz\n        op_z[i + 1] = sz\n        H -= J * producto_tensorial(op_z)\n\n    for i in range(N):\n        op_x = [I] * N\n        op_x[i] = sx\n        H -= g * producto_tensorial(op_x)\n\n    return H\n</code></pre> <p>Construye el estado inicial con todos los espines hacia arriba.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de espines.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Vector columna de dimensi\u00f3n 2^N representando |0...0\u27e9.</p> Example <p>psi0 = estado_inicial(3)</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def estado_inicial(N):\n    \"\"\"\n    Construye el estado inicial con todos los espines hacia arriba.\n\n    Args:\n        N (int): N\u00famero de espines.\n\n    Returns:\n        np.ndarray: Vector columna de dimensi\u00f3n 2^N representando |0...0\u27e9.\n\n    Example:\n        &gt;&gt;&gt; psi0 = estado_inicial(3)\n    \"\"\"\n    arriba = np.array([[1], [0]])\n    psi0 = producto_tensorial([arriba] * N)\n    return psi0\n</code></pre> <p>Construye el operador sigma z actuando en el sitio i de una cadena de N espines.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>int</code> <p>N\u00famero de espines.</p> required <code>i</code> <code>int</code> <p>\u00cdndice del sitio.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Matriz 2^N x 2^N del operador sigma_z en el sitio i.</p> Example <p>Sz_0 = sigma_z_en_i(3, 0) Sz_0.shape (8, 8)</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def sigma_z_en_i(N, i):\n    \"\"\"\n    Construye el operador sigma z actuando en el sitio i de una cadena de N espines.\n\n    Args:\n        N (int): N\u00famero de espines.\n        i (int): \u00cdndice del sitio.\n\n    Returns:\n        np.ndarray: Matriz 2^N x 2^N del operador sigma_z en el sitio i.\n\n    Example:\n        &gt;&gt;&gt; Sz_0 = sigma_z_en_i(3, 0)\n        &gt;&gt;&gt; Sz_0.shape\n        (8, 8)\n    \"\"\"\n    ops = [I] * N\n    ops[i] = sz\n    return producto_tensorial(ops)\n</code></pre> <p>Calcula la evoluci\u00f3n temporal del estado cu\u00e1ntico bajo el Hamiltoniano dado.</p> <p>Parameters:</p> Name Type Description Default <code>psi0</code> <code>ndarray</code> <p>Estado inicial (vector columna).</p> required <code>H</code> <code>ndarray</code> <p>Hamiltoniano.</p> required <code>tiempos</code> <code>ndarray</code> <p>Array de tiempos en los que evaluar.</p> required <p>Returns:</p> Type Description <p>list of np.ndarray: Lista de estados evolucionados |\u03c8(t)\u27e9.</p> Example <p>estados = evolucion(psi0, H, np.linspace(0, 1, 5))</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def evolucion(psi0, H, tiempos):\n    \"\"\"\n    Calcula la evoluci\u00f3n temporal del estado cu\u00e1ntico bajo el Hamiltoniano dado.\n\n    Args:\n        psi0 (np.ndarray): Estado inicial (vector columna).\n        H (np.ndarray): Hamiltoniano.\n        tiempos (np.ndarray): Array de tiempos en los que evaluar.\n\n    Returns:\n        list of np.ndarray: Lista de estados evolucionados |\u03c8(t)\u27e9.\n\n    Example:\n        &gt;&gt;&gt; estados = evolucion(psi0, H, np.linspace(0, 1, 5))\n    \"\"\"\n    estados = []\n    for t in tiempos:\n        U = expm(-1j * H * t)\n        psi_t = U @ psi0\n        estados.append(psi_t)\n    return estados\n</code></pre> <p>Calcula la magnetizaci\u00f3n en z sigma:_z(t) para cada esp\u00edn y cada instante.</p> <p>Parameters:</p> Name Type Description Default <code>estados</code> <code>list of np.ndarray</code> <p>Lista de estados phi(t).</p> required <code>N</code> <code>int</code> <p>N\u00famero de espines.</p> required <p>Returns:</p> Type Description <p>np.ndarray: Matriz (len(estados), N) con \u27e8sigma_z_i\u27e9(t).</p> Example <p>magz = magnetizacion_z(estados, 4)</p> Source code in <code>Implementaci\u00f3nenpython/Ising.py</code> <pre><code>def magnetizacion_z(estados, N):\n    \"\"\"\n    Calcula la magnetizaci\u00f3n en z sigma:_z(t) para cada esp\u00edn y cada instante.\n\n    Args:\n        estados (list of np.ndarray): Lista de estados phi(t).\n        N (int): N\u00famero de espines.\n\n    Returns:\n        np.ndarray: Matriz (len(estados), N) con \u27e8sigma_z_i\u27e9(t).\n\n    Example:\n        &gt;&gt;&gt; magz = magnetizacion_z(estados, 4)\n    \"\"\"\n    magnetizaciones = np.zeros((len(estados), N))\n    for t_idx, psi in enumerate(estados):\n        for i in range(N):\n            Sz_i = sigma_z_en_i(N, i)\n            magnetizaciones[t_idx, i] = np.real((psi.conj().T @ Sz_i @ psi).item())\n    return magnetizaciones\n</code></pre>"},{"location":"resultados/","title":"Resultados","text":"<p>A continuaci\u00f3n se presenta la evoluci\u00f3n temporal de los valores esperados \u27e8\u03c3\u1dbb\u27e9 para cada sitio del modelo de Ising cu\u00e1ntico unidimensional:</p> <p> </p> <p>Como se puede observar, el comportamiento de los espines var\u00eda en el tiempo debido a la din\u00e1mica cu\u00e1ntica gobernada por el Hamiltoniano total del sistema.</p>"}]}