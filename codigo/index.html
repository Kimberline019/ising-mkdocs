
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Documentación del proyecto de simulación cuántica en una cadena de espines">
      
      
      
        <link rel="canonical" href="https://Kimberline019.github.io/ising-mkdocs/codigo/">
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../ising/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.12">
    
    
      
        <title>Código - Modelo de Ising Cuántico</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.2afb09e1.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="cyan">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#codigo-del-modelo-de-ising-cuantico-en-python" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Modelo de Ising Cuántico" class="md-header__button md-logo" aria-label="Modelo de Ising Cuántico" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Modelo de Ising Cuántico
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Código
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
  
    
  
  Inicio

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="./" class="md-tabs__link">
        
  
  
    
  
  Código

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../ising/" class="md-tabs__link">
        
  
  
    
  
  Código

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../resultados/" class="md-tabs__link">
        
  
  
    
  
  Resultados

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../doxygen/html/" class="md-tabs__link">
        
  
  
    
  
  Documentación

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Modelo de Ising Cuántico" class="md-nav__button md-logo" aria-label="Modelo de Ising Cuántico" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Modelo de Ising Cuántico
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Inicio
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Código
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Código
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hamiltoniano-del-modelo" class="md-nav__link">
    <span class="md-ellipsis">
      Hamiltoniano del modelo
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementacion-del-modelo-en-python" class="md-nav__link">
    <span class="md-ellipsis">
      Implementación del modelo en Python
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Implementación del modelo en Python">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#matrices-de-pauli-y-matriz-identidad" class="md-nav__link">
    <span class="md-ellipsis">
      Matrices de Pauli y matriz identidad
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#producto-tensorial" class="md-nav__link">
    <span class="md-ellipsis">
      Producto tensorial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#construccion-del-hamiltoniano" class="md-nav__link">
    <span class="md-ellipsis">
      Construcción del Hamiltoniano
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estado-inicial-todos-los-espines-arriba" class="md-nav__link">
    <span class="md-ellipsis">
      Estado inicial: todos los espines arriba
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evolucion-temporal-del-sistema" class="md-nav__link">
    <span class="md-ellipsis">
      Evolución temporal del sistema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operador-z-en-el-sitio-i" class="md-nav__link">
    <span class="md-ellipsis">
      Operador σ^z en el sitio i
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#magnetizacion-langle-sigmaz_i-rangle-t" class="md-nav__link">
    <span class="md-ellipsis">
      Magnetización \( \langle \sigma^z_i \rangle (t) \)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametros-y-ejecucion-de-la-simulacion" class="md-nav__link">
    <span class="md-ellipsis">
      Parámetros y ejecución de la simulación
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementacion-en-c" class="md-nav__link">
    <span class="md-ellipsis">
      Implementación en C++
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matrizcpp" class="md-nav__link">
    <span class="md-ellipsis">
      Matriz.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matrizhpp" class="md-nav__link">
    <span class="md-ellipsis">
      Matriz.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hamiltonianocpp" class="md-nav__link">
    <span class="md-ellipsis">
      hamiltoniano.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hamiltonianohpp" class="md-nav__link">
    <span class="md-ellipsis">
      hamiltoniano.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#maincpp" class="md-nav__link">
    <span class="md-ellipsis">
      main.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#paulicpp" class="md-nav__link">
    <span class="md-ellipsis">
      pauli.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#paulihpp" class="md-nav__link">
    <span class="md-ellipsis">
      pauli.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rk4cpp" class="md-nav__link">
    <span class="md-ellipsis">
      rk4.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rk4hpp" class="md-nav__link">
    <span class="md-ellipsis">
      rk4.hpp
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../ising/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Código
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../resultados/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Resultados
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../doxygen/html/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Documentación
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#hamiltoniano-del-modelo" class="md-nav__link">
    <span class="md-ellipsis">
      Hamiltoniano del modelo
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementacion-del-modelo-en-python" class="md-nav__link">
    <span class="md-ellipsis">
      Implementación del modelo en Python
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Implementación del modelo en Python">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#matrices-de-pauli-y-matriz-identidad" class="md-nav__link">
    <span class="md-ellipsis">
      Matrices de Pauli y matriz identidad
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#producto-tensorial" class="md-nav__link">
    <span class="md-ellipsis">
      Producto tensorial
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#construccion-del-hamiltoniano" class="md-nav__link">
    <span class="md-ellipsis">
      Construcción del Hamiltoniano
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estado-inicial-todos-los-espines-arriba" class="md-nav__link">
    <span class="md-ellipsis">
      Estado inicial: todos los espines arriba
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#evolucion-temporal-del-sistema" class="md-nav__link">
    <span class="md-ellipsis">
      Evolución temporal del sistema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operador-z-en-el-sitio-i" class="md-nav__link">
    <span class="md-ellipsis">
      Operador σ^z en el sitio i
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#magnetizacion-langle-sigmaz_i-rangle-t" class="md-nav__link">
    <span class="md-ellipsis">
      Magnetización \( \langle \sigma^z_i \rangle (t) \)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametros-y-ejecucion-de-la-simulacion" class="md-nav__link">
    <span class="md-ellipsis">
      Parámetros y ejecución de la simulación
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#implementacion-en-c" class="md-nav__link">
    <span class="md-ellipsis">
      Implementación en C++
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matrizcpp" class="md-nav__link">
    <span class="md-ellipsis">
      Matriz.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#matrizhpp" class="md-nav__link">
    <span class="md-ellipsis">
      Matriz.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hamiltonianocpp" class="md-nav__link">
    <span class="md-ellipsis">
      hamiltoniano.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hamiltonianohpp" class="md-nav__link">
    <span class="md-ellipsis">
      hamiltoniano.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#maincpp" class="md-nav__link">
    <span class="md-ellipsis">
      main.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#paulicpp" class="md-nav__link">
    <span class="md-ellipsis">
      pauli.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#paulihpp" class="md-nav__link">
    <span class="md-ellipsis">
      pauli.hpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rk4cpp" class="md-nav__link">
    <span class="md-ellipsis">
      rk4.cpp
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#rk4hpp" class="md-nav__link">
    <span class="md-ellipsis">
      rk4.hpp
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="codigo-del-modelo-de-ising-cuantico-en-python">Código del modelo de Ising cuántico en Python<a class="headerlink" href="#codigo-del-modelo-de-ising-cuantico-en-python" title="Permanent link">&para;</a></h1>
<p>Este apartado presenta la implementación completa del <strong>modelo de Ising cuántico unidimensional con campo transversal</strong>, un sistema fundamental en la física de muchos cuerpos. A continuación, se explica cada parte del código que simula su dinámica cuántica.</p>
<hr />
<h2 id="hamiltoniano-del-modelo">Hamiltoniano del modelo<a class="headerlink" href="#hamiltoniano-del-modelo" title="Permanent link">&para;</a></h2>
<p>El Hamiltoniano está dado por:</p>
<div class="arithmatex">\[
H = -J \sum_{i=1}^{N-1} \sigma^z_i \sigma^z_{i+1} - g \sum_{i=1}^N \sigma^x_i
\]</div>
<p>donde:
- <span class="arithmatex">\( \sigma^x \)</span> y <span class="arithmatex">\( \sigma^z \)</span> son matrices de Pauli,<br />
- <span class="arithmatex">\( J \)</span> es la constante de acoplamiento entre espines vecinos,<br />
- <span class="arithmatex">\( g \)</span> es la intensidad del campo transversal,<br />
- <span class="arithmatex">\( N \)</span> es el número total de espines en la cadena.</p>
<hr />
<h2 id="implementacion-del-modelo-en-python">Implementación del modelo en Python<a class="headerlink" href="#implementacion-del-modelo-en-python" title="Permanent link">&para;</a></h2>
<pre><code class="language-python">import numpy as np
from functools import reduce
from scipy.linalg import expm
</code></pre>
<h3 id="matrices-de-pauli-y-matriz-identidad">Matrices de Pauli y matriz identidad<a class="headerlink" href="#matrices-de-pauli-y-matriz-identidad" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">I = np.eye(2)
sx = np.array([[0, 1], [1, 0]])   # σ_x
sz = np.array([[1, 0], [0, -1]])  # σ_z
</code></pre>
<h3 id="producto-tensorial">Producto tensorial<a class="headerlink" href="#producto-tensorial" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def producto_tensorial(matrices):
    return reduce(np.kron, matrices)
</code></pre>
<h3 id="construccion-del-hamiltoniano">Construcción del Hamiltoniano<a class="headerlink" href="#construccion-del-hamiltoniano" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def hamiltoniano(N, J, g):
    H = np.zeros((2**N, 2**N))

    # Término de interacción σ^z_i σ^z_{i+1}
    for i in range(N - 1):
        op_z = [I] * N
        op_z[i] = sz
        op_z[i + 1] = sz
        H -= J * producto_tensorial(op_z)

    # Término de campo transversal σ^x_i
    for i in range(N):
        op_x = [I] * N
        op_x[i] = sx
        H -= g * producto_tensorial(op_x)

    return H
</code></pre>
<h3 id="estado-inicial-todos-los-espines-arriba">Estado inicial: todos los espines arriba<a class="headerlink" href="#estado-inicial-todos-los-espines-arriba" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def estado_inicial(N):
    arriba = np.array([[1], [0]])  # Estado |0⟩
    return producto_tensorial([arriba] * N)
</code></pre>
<h3 id="evolucion-temporal-del-sistema">Evolución temporal del sistema<a class="headerlink" href="#evolucion-temporal-del-sistema" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def evolucion(psi0, H, tiempos):
    estados = []
    for t in tiempos:
        U = expm(-1j * H * t)
        psi_t = U @ psi0
        estados.append(psi_t)
    return estados
</code></pre>
<h3 id="operador-z-en-el-sitio-i">Operador σ^z en el sitio i<a class="headerlink" href="#operador-z-en-el-sitio-i" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def sigma_z_en_i(N, i):
    ops = [I] * N
    ops[i] = sz
    return producto_tensorial(ops)
</code></pre>
<h3 id="magnetizacion-langle-sigmaz_i-rangle-t">Magnetización <span class="arithmatex">\( \langle \sigma^z_i \rangle (t) \)</span><a class="headerlink" href="#magnetizacion-langle-sigmaz_i-rangle-t" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">def magnetizacion_z(estados, N):
    magnetizaciones = np.zeros((len(estados), N))
    for t_idx, psi in enumerate(estados):
        for i in range(N):
            Sz_i = sigma_z_en_i(N, i)
            magnetizaciones[t_idx, i] = np.real((psi.conj().T @ Sz_i @ psi).item())
    return magnetizaciones
</code></pre>
<h3 id="parametros-y-ejecucion-de-la-simulacion">Parámetros y ejecución de la simulación<a class="headerlink" href="#parametros-y-ejecucion-de-la-simulacion" title="Permanent link">&para;</a></h3>
<pre><code class="language-python">N = 4
J = 1.0
g = 1.0

H = hamiltoniano(N, J, g)
psi0 = estado_inicial(N)
tiempos = np.linspace(0, 5, 100)
estados = evolucion(psi0, H, tiempos)
magnetizaciones = magnetizacion_z(estados, N)
</code></pre>
<h2 id="implementacion-en-c">Implementación en C++<a class="headerlink" href="#implementacion-en-c" title="Permanent link">&para;</a></h2>
<h2 id="matrizcpp">Matriz.cpp<a class="headerlink" href="#matrizcpp" title="Permanent link">&para;</a></h2>
<p>Este código implementa una clase Matriz que representa matrices de números complejos y define operaciones fundamentales como suma, multiplicación matricial, multiplicación por escalar y producto tensorial, todas optimizadas con paralelización mediante OpenMP; su propósito dentro del modelo de Ising cuántico unidimensional es facilitar la construcción eficiente del Hamiltoniano a través de productos tensoriales de matrices de Pauli, así como la evolución del estado cuántico mediante multiplicaciones repetidas de matrices durante la integración numérica de la ecuación de Schrödinger.</p>
<pre><code class="language-cpp">#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &quot;Matriz.hpp&quot;
#include &lt;omp.h&gt;
Matriz::Matriz(int filas_,int columnas_): filas(filas_), columnas(columnas_),data(filas*columnas, {0.0,0.0}){}
Matriz::Matriz(int filas_,int columnas_,const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores): filas(filas_),columnas(columnas_), data(valores){}
Matriz Matriz::operator+(const Matriz &amp;obj) const {
    Matriz newMatriz(filas,columnas);
    #pragma omp parallel for
    for (int i=0; i &lt;filas;++i){
        for (int j=0; j &lt;columnas;++j){
        newMatriz(i,j)=(*this)(i,j)+obj(i,j);
        }
    }
    return newMatriz;
}

int Matriz::sizef() const {
    return filas;
}
int Matriz::sizec() const {
    return columnas;
}
std::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j){
    return data[i*columnas+j];
}
const std::complex&lt;double&gt;&amp; Matriz::operator()(int i, int j) const{
        return data[i*columnas+j];
}
const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; Matriz::datos() const {
    return data;
}
Matriz Matriz::operator*(const Matriz &amp;obj) const{
     Matriz newMatriz(filas,obj.sizec());
     #pragma omp parallel for
     for (int i = 0; i &lt; filas; ++i){
            for (int j = 0; j &lt; obj.sizec(); ++j){
                    for (int k = 0; k &lt; columnas; ++k){
                        newMatriz(i, j) += (*this)(i, k) * obj(k, j);
            }
        }
     }
         return newMatriz;
}
Matriz Matriz::operator*(const std::complex&lt;double&gt;&amp; escalar) const{
    Matriz newMatriz(filas,columnas);
    #pragma omp parallel for
    for (int i=0; i &lt; filas; ++i){
        for (int j = 0; j &lt; columnas; ++j){
            newMatriz(i,j)=(*this)(i, j) * escalar;
        }
    }
    return newMatriz;
}
Matriz Matriz::tensor(const Matriz &amp;obj) const {
    int m = filas;
    int n = columnas;
    int p = obj.sizef();
    int q = obj.sizec();
    Matriz newMatriz(m*p,n*q);
    #pragma omp parallel for collapse(2)
    for (int i=0;i&lt;m;++i){
        for (int j=0;j&lt;n;++j){
            for (int k=0;k&lt;p;++k){
                for (int l=0;l&lt;q;++l){
                    newMatriz(i*p+k,j*q+l)=(*this)(i,j)*obj(k,l);
                }
            }
        }
    }

    return newMatriz;
}
</code></pre>
<h2 id="matrizhpp">Matriz.hpp<a class="headerlink" href="#matrizhpp" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">
#ifndef MATRIZ_HPP 
#define MATRIZ_HPP 

#include &lt;vector&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
/**
 * @brief Representa matrices. 
 * Simplifica cálculos con matrices mediante operadores, lo que evita for loops explícitos en el resto del código.
 * Almacena las dimensiones de la matriz en variables int  y sus datos en un std::vector&lt;std::complex&lt;double&gt;&gt;
 */
class Matriz {
    private:
        int filas, columnas;
        std::vector&lt;std::complex&lt;double&gt;&gt; data;
    public:
        /**
        * @brief Constructor personalizado que representa una matriz con el tamaño y datos dados.
        * Ejemplo de uso:
        * @code
        *  Matriz B(2,2,({1,0},{0,0},{0,1},{0,1});
        * @endcode
        *
        * @param filas  Número de filas.
        * @param columnas  Número de columnas.
        * @param vector complejo con los datos aplanados de la matriz.
        */
        Matriz(int filas, int columnas, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp;valores);
        /**
        * @brief Constructor personalizado que representa una matriz no inicializada con el tamaño dado.
        *
        * Ejemplo de uso:
        * @code
        * Matriz A(2,2);
        * @endcode
        *
        * @param filas Número de filas.
        * @param columnas Número de columnas.
        */
        Matriz(int filas, int columnas);
         /**
         * @brief Realiza la suma de dos matrices.
         *
         * Ejemplo de uso:
         * @code
         * Matriz C=A+B;
         * @endcode
         *
         * @param &amp;obj Matriz a la derecha de la suma.
         * @return La suma de ambas matrices.
         */
        Matriz operator+(const Matriz &amp;obj) const;
                 /**
                 * @brief Realiza el producto entre dos matrices.
                 *
                 * Ejemplo de uso:
                 * @code
                 * Matriz C=A*B;
                 * @endcode
                 *
                 * @param &amp;obj Matriz a la derecha del producto.
                 * @return El producto matricial.
                 */
        Matriz operator*(const Matriz &amp;obj) const;
                 /**
                 * @brief Realiza el producto escalar.
                 *
                 * Ejemplo de uso:
                 * @code
                 * Matriz C=A*b;
                 * @endcode
                 *
                 * @param &amp;escalar escalar por el que se va a multiplicar (debe siempre estar a la derecha de la matriz).
                 * @return Resultado del producto.
                 */
        Matriz operator*(const std::complex&lt;double&gt; &amp;escalar) const;
         /**
                 * @brief Realiza el producto tensorial.
                 *
                 * Ejemplo de uso:
                 * @code
                 * Matriz C=A.tensor(B);
                 * @endcode
                 *
                 * @param &amp;obj Matriz derecha por la que se realizará el producto tensorial.
                 * @return Matriz resultado del producto tensorial.
                 */
        Matriz tensor(const Matriz &amp;obj) const;
         /**
                 * @brief Da la cantidad de filas de la matriz.
                 *
                 * Ejemplo de uso:
                 * @code
                 * int b=A.sizef();
         * //b=2
                 * @endcode
                 *
                 * @return Número de filas de la matriz.
                 */
        int sizef() const;
         /**
                 * @brief Da la cantidad de columnas de la matriz.
                 *
                 * Ejemplo de uso:
                 * @code
                 * int b=A.sizec();
                 * //b=2
                 * @endcode
                 *
                 * @return Número de columnas de la matriz.
                 */
        int sizec() const;
         /**
                 * @brief Permite accesar un dato de la matriz aplanada de forma intuitiva para aplicaciones de la clase.
                 *
                 * Ejemplo de uso:
                 * @code
                 * std::complex&lt;double&gt;&gt; b=A(2,2);
                 * //b={1.0,0.0}
                 * @endcode
                 *
         * @param i Fila del dato a accesar.
         * @param j Columna del dato a accesar.
                 * @return Dato en la posición (i,j) de la matriz.
                 */
        std::complex&lt;double&gt;&amp; operator()(int i, int j);
         /* @brief Permite accesar un dato de la matriz aplanada de forma intuitiva para aplicaciones externas.
                 *
                 * Ejemplo de uso:
                 * @code
                 * std::complex&lt;double&gt;&gt; b=A(2,2);
                 * //b={1.0,0.0}
                 * @endcode
                 *
                 * @param i Fila del dato a accesar.
                 * @param j Columna del dato a accesar.
                 * @return Dato en la posición (i,j) de la matriz.
                 */
        const std::complex&lt;double&gt;&amp; operator()(int i, int j) const;
         /* @brief Devuelve el vector complejo que almacena los datos de la matriz.
                 *
                 * Ejemplo de uso:
                 * @code
                 * std::vector&lt;std::complex&lt;double&gt;&gt; b=A.datos()
                 * //b=({1,0},{0,0},{0,1},{0,1})
                 * @endcode
                 *
                 * @param i Fila del dato a accesar.
                 * @param j Columna del dato a accesar.
                 * @return Dato en la posición (i,j) de la matriz.
                 */
        const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; datos() const;
                 /* @brief Devuelve la norma de un vector columna.
                 *
                 * Ejemplo de uso:
                 * @code
                 * double b=A.norma()
                 * //b=sqrt(5)
                 * @endcode
                 *
                 * @return Norma del vector.
                 */
        double norma() const;
};

</code></pre>
<h2 id="hamiltonianocpp">hamiltoniano.cpp<a class="headerlink" href="#hamiltonianocpp" title="Permanent link">&para;</a></h2>
<p>El archivo hamiltoniano.cpp define una clase Hamiltoniano que construye la matriz Hamiltoniana del modelo de Ising cuántico unidimensional en una red de $$ ( N )$$ espines, empleando productos tensoriales de matrices de Pauli. El término de interacción $$ ( -J \sum_i \sigma^z_i \sigma^z_{i+1} )$$ se implementa mediante ciclos que insertan dos matrices$$ (\sigma^z)$$ en las posiciones correspondientes y matrices identidad en los sitios restantes, considerando condiciones periódicas. El término de campo transversal $$ ( -g \sum_i \sigma^x_i )$$  se construye de forma similar, insertando$$ (\sigma^x)$$  en la posición adecuada. La matriz resultante $$ ( \hat{H} )$$ es de dimensión <span class="arithmatex">\(<span class="arithmatex">\(( 2^N \times 2^N )\)</span>\)</span> y se guarda internamente para su posterior uso en la evolución dinámica del sistema.</p>
<pre><code class="language-cpp">#include &quot;hamiltoniano.hpp&quot;
#include &quot;pauli.hpp&quot; 
#include &lt;iostream&gt;

Hamiltoniano::Hamiltoniano(int N_): N(N_),H(1 &lt;&lt; N_, 1 &lt;&lt; N_) {
    int dim =1&lt;&lt;N; 
    H=Matriz(dim, dim);
}
void Hamiltoniano::construir(double J, double g) {
    int dim =1 &lt;&lt;N;
    H=Matriz(dim,dim);
    for (int i=0;i&lt;N;++i){
        int ip =(i+1)%N;
        Matriz term_zz=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});
        for (int site=0;site&lt;N;++site){
            if (site == i)
                term_zz=term_zz.tensor(Pauli::Z());
            else if (site==ip)
                term_zz=term_zz.tensor(Pauli::Z());
            else
                term_zz = term_zz.tensor(Pauli::I());
        }
        H=H+term_zz*(-J);
    }
    for (int i=0;i&lt;N;++i){
        Matriz term_x=Matriz(1,1,{std::complex&lt;double&gt;(1,0)});
        for (int site=0;site&lt;N;++site){
            if (site==i)
                term_x=term_x.tensor(Pauli::X());
            else
                term_x=term_x.tensor(Pauli::I());
        }
        H=H+term_x*(-g);
    }
}

const Matriz&amp; Hamiltoniano::matriz() const {
    return H;
}
</code></pre>
<h2 id="hamiltonianohpp">hamiltoniano.hpp<a class="headerlink" href="#hamiltonianohpp" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">
#include &quot;Matriz.hpp&quot;
#include &lt;vector&gt;
#include &lt;complex&gt;
/**
 * @brief Esta clase se encarga de realizar las operaciones necesarias para construir el Hamiltoniano del sistema a partir de los valores datos.
 *Almacena la matriz del Hamiltoniano y la cantidad de espines del sistema.
 * 
 */
class Hamiltoniano {
private:
    Matriz H;            
    int N;            
public:
    /**
    * @brief Constructor personalizado que crea una matriz sin inicializar de las dimensiones del Hamiltoniano del sistema.
    *
    * Ejemplo de uso:
    * @code
    * Hamiltoniano H_(espin);
    * @endcode
    */
    Hamiltoniano(int N_);
    /**
    * @brief Realiza los productos tensoriales necesarios para crear la matriz del Hamiltoniano del sistema y los almacena en los datos de la instancia.
    *
    * Ejemplo de uso:
    * @code
    * H_,construir(J,g);
    * @endcode
    *
    * @param J dato de la escala energética de la interacción ferromagnética.
    * @param g dato del parámetro energético del campo transversal.
    */
    void construir(double J, double g); 
        /**
    * @brief Devuelve el hamiltoniano del que la clase almacena.
    *
    * Ejemplo de uso:
    * @code
    * H=H_,matriz();
    * @endcode
    *
    * @return Matriz con el hamiltoniano de la clase.
    */
    const Matriz&amp; matriz() const;
};

</code></pre>
<h2 id="maincpp">main.cpp<a class="headerlink" href="#maincpp" title="Permanent link">&para;</a></h2>
<p>El archivo <strong>main.cpp</strong> realiza la simulación numérica de la dinámica del modelo de Ising  a través de un enfoque de evolución temporal. El usuario ingresa el número de hilos a utilizar mediante OpenMP para aprovechar la paralelización del cálculo. A partir de un estado inicial puro, se construye la matriz Hamiltoniana  <span class="arithmatex">\(\hat{H}\)</span>  del sistema utilizando productos tensoriales de matrices de Pauli y se resuelve la ecuación de Schrödinger dependiente del tiempo utilizando el método de Runge-Kutta de cuarto orden, implementado en la clase <strong>rk4</strong>. Además, se evalúa la evolución unitaria exacta mediante una expansión de Taylor truncada, permitiendo comparar y validar el método numérico. Finalmente, se mide el tiempo total de ejecución para evaluar el desempeño computacional según el número de hilos empleados, lo cual es esencial para el análisis de aceleración (<strong>speedup</strong>) en cálculos paralelos.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &quot;Matriz.hpp&quot;
#include &quot;hamiltoniano.hpp&quot;
#include &quot;rk4.hpp&quot;
#include &quot;pauli.hpp&quot;
#include &lt;omp.h&gt;
#include &lt;sys/time.h&gt;

double seconds() {
    struct timeval tmp;
    gettimeofday(&amp;tmp, nullptr);
    return tmp.tv_sec + tmp.tv_usec * 1e-6;
}


int main(){
    double J=1.0;
    double g=1.0;
    double tF=2.0;
    double h=0.0001;
    int spin = 3;
    int n=100;

   int num_threads;
    std::cout &lt;&lt; &quot;Ingrese el número de hilos a usar: &quot;;
    std::cin &gt;&gt; num_threads;
    omp_set_num_threads(num_threads); 


        int dim = 1 &lt;&lt; spin; 
    std::vector&lt;std::complex&lt;double&gt;&gt; inicial(dim, {1.0, 0.0});
    Matriz phi0(dim,1,inicial);
    Matriz phicopy(dim,1);

    Hamiltoniano H_(spin);
    H_.construir(J,g);
    Matriz H=H_.matriz();

    rk4 rk4(H,h);

    double time_start = seconds();

    double contador=0;
    while (contador &lt;=tF){
        phicopy=rk4.aplicar(phi0); 
        std::cout&lt;&lt;&quot;t = &quot;&lt;&lt; contador&lt;&lt; std::endl;
        for (int i=0;i&lt; phicopy.sizef();++i){
                std::cout &lt;&lt; phicopy(i,0)&lt;&lt; std::endl;
            }
        std::cout &lt;&lt; std::endl;
        contador+=h;
        phi0=phicopy;
    }
    phicopy=rk4.direct(phi0,n,tF);
    for (int i=0;i&lt;phicopy.sizef();++i){
            std::cout&lt;&lt;phicopy(i,0)&lt;&lt;std::endl;
        }
        std::cout &lt;&lt; std::endl;

    double time_end = seconds();
    std::cout &lt;&lt; &quot;Tiempo de ejecución: &quot; &lt;&lt; (time_end - time_start) &lt;&lt; &quot; segundos&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Número de hilos utilizados: &quot; &lt;&lt; num_threads &lt;&lt; std::endl;
    return 0;
    }
</code></pre>
<h2 id="paulicpp">pauli.cpp<a class="headerlink" href="#paulicpp" title="Permanent link">&para;</a></h2>
<p>El archivo $$ \texttt{pauli.cpp}$$ define funciones estáticas de la clase Pauli que retornan las matrices de Pauli <span class="arithmatex">\(<span class="arithmatex">\(( \hat{I} )\)</span>\)</span>, <span class="arithmatex">\(4( \hat{\sigma}^x )\)</span>$  y $$ ( \hat{\sigma}^z )$$  representadas como objetos de la clase Matriz. Estas matrices son fundamentales en la construcción del Hamiltoniano del modelo de Ising cuántico unidimensional, ya que <span class="arithmatex">\(<span class="arithmatex">\(( \hat{\sigma}^z )\)</span>\)</span>  se utiliza para modelar la interacción entre espines vecinos, mientras que $$ ( \hat{\sigma}^x )$$ representa el efecto del campo magnético transversal. La matriz identidad <span class="arithmatex">\(<span class="arithmatex">\(( \hat{I} )\)</span>\)</span> se emplea para completar los productos tensoriales cuando un operador actúa sobre un sitio específico de la cadena de espines</p>
<pre><code class="language-cpp">#include &quot;pauli.hpp&quot;

Matriz Pauli::I(){
    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0)});
}
Matriz Pauli::X(){
return Matriz(2,2,{std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0)});
}
Matriz Pauli::Z(){
    return Matriz(2,2,{std::complex&lt;double&gt;(1,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(0,0),std::complex&lt;double&gt;(-1,0)});
</code></pre>
<h2 id="paulihpp">pauli.hpp<a class="headerlink" href="#paulihpp" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">
#ifndef PAULI_H
#define PAULI_H
#include &quot;Matriz.hpp&quot;
/**
 * @brief Define las matrices de Pauli usando la clase Matriz como constantes para su fácil acceso.
 *
 */
class Pauli {
public:
    static Matriz I();
</code></pre>
<h2 id="rk4cpp">rk4.cpp<a class="headerlink" href="#rk4cpp" title="Permanent link">&para;</a></h2>
<p>El archivo rk4.cpp implementa la clase rk4, que permite resolver numéricamente la ecuación de Schrödinger dependiente del tiempo para un sistema cuántico, utilizando dos métodos: el método de Runge-Kutta de cuarto orden y una aproximación directa de la evolución unitaria basada en el desarrollo en serie de Taylor de la exponencial de matrices. El método aplicar calcula un paso de evolución temporal aplicando el algoritmo de Runge-Kutta a la función de onda <span class="arithmatex">\(( |\psi(t)\rangle )\)</span>, con un paso de tiempo ( h ), usando la matriz Hamiltoniana <span class="arithmatex">\(( \hat{H} )\)</span>. Por otro lado, el método direct evalúa directamente  <span class="arithmatex">\(( e^{-i\hat{H}t}|\psi(0)\rangle )\)</span> truncando la serie de potencias en $( n ) términos, lo cual es útil para validar la precisión del método numérico. Ambas estrategias son fundamentales para estudiar la dinámica del modelo de Ising a partir de un estado inicial.</p>
<pre><code class="language-cpp">
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;complex&gt;
#include &lt;iostream&gt;
#include &quot;Matriz.hpp&quot;
#include &quot;rk4.hpp&quot;

rk4::rk4(const Matriz&amp; Hamiltoniano, double paso):H(Hamiltoniano),h(paso) {}
Matriz rk4::aplicar(const Matriz &amp;phi0) const{
    std::complex&lt;double&gt; z(0.0, -1.0);
    std::complex&lt;double&gt; coef= z*h;
    Matriz k1(phi0.sizef(),1),k2(phi0.sizef(),1),k3(phi0.sizef(),1),k4(phi0.sizef(),1);
    k1=H*phi0*coef;
    k2=H*(phi0+k1*0.5)*coef;
    k3=H*(phi0+k2*0.5)*coef;
    k4=H*(phi0+k3)*coef;
    return phi0+(k1+k2*2+k3*2+k4)*(1.0/6.0);
}
Matriz rk4::direct(const Matriz&amp; phi0,int &amp;n,double &amp;t) const{
        std::complex&lt;double&gt; z(0.0, -1.0);
     Matriz phi1(phi0.sizef(), 1);
         Matriz identidad(H.sizef(), H.sizec());
        for (int i = 0; i &lt; H.sizef(); ++i) {
            identidad(i, i) = {1.0, 0.0};
        }
        Matriz suma = identidad;
        Matriz potenciaH = identidad;
        std::complex&lt;double&gt; coef = 1.0;  // Coeficiente factorial
        for (int k=1;k&lt;=n;++k){
            potenciaH = potenciaH*H;
            coef /= static_cast&lt;double&gt;(k);
            suma =suma+potenciaH*(coef*std::pow(z*t,k));
        }

        phi1 = suma*phi0;
        return phi1;
}
</code></pre>
<h2 id="rk4hpp">rk4.hpp<a class="headerlink" href="#rk4hpp" title="Permanent link">&para;</a></h2>
<pre><code class="language-cpp">
#include &lt;vector&gt;
#include &lt;complex&gt;
#include &quot;Matriz.hpp&quot;
/**
 * @brief Almacena los métodos de cálculo para el phi final.
 *
 * Sus operadores permiten calcular limpiamente el estado final de phi. Almacena el hamiltoniano del sistema y el tamaño del paso a aplicar.
 */ 
class rk4 {
private:
    Matriz H;
    double h;
public:
    /**
     * @brief Constructor personalizado que almacena los datos necesarios para el método numérico.
     * Ejemplo de uso: 
     * @code 
     * rk4 metodo(H,0.001);
     *  @endcode
     *
     * @param &amp;Hamiltoniano El hamiltoniano del sistema.
     * @param Paso Tamaño del paso que aplicará el método numérico.
     */
    rk4(const Matriz&amp; Hamiltoniano, double paso);
        /**
     * @brief Aplica una iteración del método Runge-Kutta grado 4.
     * Ejemplo de uso:
     * @code
     * Matriz v= metodo.aplicar(phi_0);
     *  @endcode
     *
     * @param &amp;phi0 Matriz con el vector columna que almacena las condiciones de phi antes de la iteración.
     * @return &amp;phi0 Matriz con el vector columna phi en el tiempo t+h.
     */
    Matriz aplicar(const Matriz &amp;phi0) const;
     /**
     * @brief Calcula mediante series de Taylor el valor de exp(-iHt) y la aplica las condiciones iniciales de phi.
     * Ejemplo de uso:
     * @code
     * Matriz v= metodo.direct(phi_0);
     *  @endcode
     *
     *@param &amp;phi0 Matriz con el vector columna que almacena las condiciones de
 phi antes de la iteración.
     *@param &amp;n Entero con el número de términos que se quieren para la expansión de Taylor.
     *@param &amp;t Tiempo final del sistema.
     *@return Matriz con el vector columna con los valores finales de phi.
     *
     * 
     */

</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.sections", "content.code.copy"], "search": "../assets/javascripts/workers/search.f8cc74c7.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.c8b220af.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>